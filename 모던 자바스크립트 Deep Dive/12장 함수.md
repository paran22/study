## 12장 함수
### 12.1 함수란?
- 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 함수 내부로 입력을 전달받는 변수를 <u>매개변수(parameter)</u>, 입력은 <u>인수(argument)</u>, 출력을 <u>반환값(return value)</u>라고 한다.
- **함수 정의**를 통해 함수를 생성하고, **함수 호출**하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 실행 결과인 반환값을 반환한다.

### 12.2 함수를 사용하는 이유
- 함수를 사용하면 함수 실행 시점을 개발자가 결정할 수 있고, 재사용이 가능하고, 유지보수 편의성을 높이고, 실수를 줄여 코드의 신뢰성을 높인다.
- 적절한 함수 이름은 함수 내부 코드를 이해하지 않고도 함수의 역할을 파악할 수 있게 하여, 코드의 가독성을 높인다.

### 12.3 함수 리터럴
- 자바스크립트의 함수는 객체 타입의 값으로, 함수 리터럴로 생성할 수 있다.
```js
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```
- 함수는 다른 객체와 달리 호출할 수 있다.
- 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 익명 함수라고 한다.
- 함수 이름은 몸체 내에서만 참조할 수 있는 식별자이다.

### 12.4 함수 정의
- 함수 정의란 **함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것**을 말한다. 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다.
- 함수를 정의하는 방식은 4가지가 있다.
#### 함수 선언문
- 함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴과 달리 **함수 이름을 생략할 수 없다.**
```js
// 함수 선언문
function add(x, y) {
  return x + y;
}
```
- 함수 선언문은 **표현식이 아닌 문**이다.
- 함수 선언문은 코드를 선두로 끌어 올려진 것처럼 동작한다(**함수 호이스팅**)
- 함수 호이스팅은 함수를 호출하기 전에 함수를 선언해야 한다는 당연한 규칙을 무시하기 때문에 함수 표현식이 더 권장된다.
```js
// 함수 참조
console.dir(add); // ƒ add(x, y)

// 함수 호출
// 함수 호이스팅에 의해 호출이 가능하다.
console.log(add(2, 5)); // 7

// 함수 선언문
function add(x, y) {
  return x + y;
}
```
- 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 수 있다.
```js
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
// 함수 이름 foo가 아니라 자바스크립트 엔진이 생성한 생성자 foo로 호출된다.
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```
- 함수 이름은 함수 내부에서만 사용할 수 있다.
- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
#### 함수 표현식
- 자바스크립트의 함수는 값의 성질을 갖는 **일급 객체**이다.
- **함수 리터럴로 생성한 함수 객체를 변수에 할당하는 것**을 함수 표현식이라 한다.
- 함수 리터럴의 함수 이름은 생략할 수 있다(익명 함수)
```js
// 함수 표현식
var add = function (x, y) {
  return x + y;
};
```
- 함수 표현식은 **변수의 할당되는 값이 함수 리터럴인 문**이다. 따라서 함수 호이스팅이 아니라 **변수 호이스팅**이 발생한다.
```js
// 함수 참조
console.dir(sub); // undefined

// 함수 호출
// 변수 할당문의 값은 할당문이 실행되는 시점에 평가되기 때문에 이 때 함수를 호출하면 undefined가 호출되어 TypeError가 발생한다.
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```
#### Function 생성자 함수
- Function 생성자 함수로 함수를 생성하는 방식은 클로저를 생성하지 않는 등 문제가 있어 권장하지 않는다.
```js
var add1 = (function () {
  var a = 10;
  return function (x, y) {
    return x + y + a;
  };
}());

console.log(add1(1, 2)); // 13

var add2 = (function () {
  var a = 10;
  return new Function('x', 'y', 'return x + y + a;');
}());

console.log(add2(1, 2)); // ReferenceError: a is not defined
```
#### 화살표 함수
- 화살표 함수는 function 키워드 대신 화살표 =>를 사용해 좀 더 간략한 방법으로 함수를 생성할 수 있다.
- 항상 익명 함수로 정의한다.
```js
// 화살표 함수
const add = (x, y) => x + y;
```

### 12.5 함수 호출
- 함수는 <u>함수를 가리키는 식별자와 함수 호출 연산자 ()로 호출한다.</u>
- 함수를 호출하면 <b>현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다.</b>
- 함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부에 전달하기 위해 <u>매개변수를 통해 인수를 전달한다.</u>
- 인수는 값으로 평가될 수 있는 표현식이어야 한다.
```js
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 호출
// 인수 1과 2는 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.
var result = add(1, 2);
```
- 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당된다.
- 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다. 인수가 부족해서 인수에 할당되지 않은 매개변수의 값은 undefined이다.
```js
function add(x, y) {
  return x + y;
}

// 2 + undefined
// NaN
console.log(add(2));
```
- 모든 인수는 arguments 객체의 프로퍼티로 보관된다.
```js
function add(x, y) {
  console.log(arguments);
  // Arguments(3) [2, 5, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]

  return x + y;
}

add(2, 5, 10);
```
- 함수 내부에 적절한 인수가 전달되었는지 확인하기 위해 함수를 정의할 때 인수의 타입을 확인하거나, 타입스크립트 사용을 권장한다.
- 인수가 전달되지 않은 경우 단축 평가를 사용하거나, 매개변수 기본값을 사용할 수 있다.
- 매개변수는 적을수록 좋다.
- <u>return 키워드와 표현식(반환값)</u>으로 이뤄진 반환값을 사용해 실행 결과를 함수 외부로 반환할 수 있다.
- 반환문의 역할은 다음과 같다. **1) 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 2) return 키워드 뒤에 오는 표현식을 평가해 반환한다.**
- 반환문은 생략할 수 있다. 이 때 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다.
```js
function foo () {
  return;
}

console.log(foo()); // undefined
```

### 12.6 참조에 의한 전달과 외부 상태의 변경
- 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 타입에 따라 값의 의한 전달, 참조에 의한 전달 방식을 그대로 따른다.
- 함수를 호출하면서 매개변수에 값을 전달하는 방식을 값에 의한 호출(call by value), 참조에 의한 호출(call by reference)로 구별해 부르는 경우도 있다.
- 원시 타입 인수는 함수 몸체에서 그 값을 변경해도 원본이 훼손되지 않는다.
- **객체 타입 인수**는 참조 값이 복사되어 전달되기 때문에 **함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 변경되는 부수 효과가 발생한다.**
```js
// 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // {name: "Lee"}

// 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달된다.
changeVal(num, person);

// 원시 값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: "Kim"}
```
- 해결 방법 중 하나는 객체의 복사본을 새로 생성해 원시 값처럼 변경 불가능한 불변 객체로 만들어 사용하는 것이다.
### 12.7 다양한 함수의 형태
#### 즉시 실행 함수
- **함수 정의와 동시에 즉시 호출되는 함수**를 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)라 한다.
- 즉시 실행 함수는 <u>단 한 번만 호출되며 다시 호출할 수 없다.</u>
- **반드시 그룹 연산자 (...)로 감싸야 한다.** 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.
```js
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());

// 기명 즉시 실행 함수
(function foo() {
  var a = 3;
  var b = 5;
  return a * b;
}());

foo(); // ReferenceError: foo is not defined
```
- 즉시 실행 함수 내에 코드를 모아 두면 변수나 함수 이름의 충돌을 방지 할 수 있다.

#### 재귀 함수
- 함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다.
- 재귀 함수는 자기 자신을 호출하는 함수를 말한다.
- 재귀 함수를 사용하면 반복되는 처리를 반복문 없이 구현할 수 있다.
```js
function countdown(n) {
  if (n < 0) return;
  console.log(n);
  countdown(n - 1); // 재귀 호출
}

countdown(10);
```
- 함수 내부에서는 함수 이름을 사용해 자기 자신을 호출할 수 있다. 함수 표현식으로 정의한 함수 내부에서는 함수 이름은 물론 함수를 가리키는 식별자로도 자기 자신을 재귀 호출할 수 있다.
- 재귀 함수는 자신을 무한 재귀 호출하기 때문에 재귀 함수 내에 재귀 호출을 멈출 수 있는 탈출 조건이 반드시 있어야 한다.
- 재귀 함수는 반복문을 사용하는 편이 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직하다.
#### 중첩 함수
- **함수 내부에 정의된 함수**를 중첩 함수(nested function) 또는 내부 함수(inner function)라고 한다.
- 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.
```js
function outer() {
  var x = 1;

  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); // 3
  }

  inner();
}

outer();
```
- ES6부터 함수 정의는 if나 for문 등의 코드 블록 내에서도 정의할 수 있으나, 호이스팅으로 혼란이 발생할 수 있기 때문에 if문이나 for문 등의 코드 블록에서 함수 선언문을 통해 함수를 정의하는 것은 권장하지 않는다.
#### 콜백 함수
- **함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수(callback function)**라고 하고, **매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차함수(Higher-Order Function, HOF)**라고 한다.
- 매개변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를 함수형 프로그래밍 패러다임에서 고차 함수라고 한다.
- 고차 함수는 콜백 함수를 자신의 일부로 합성한다.
- **고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.**
- 콜백 함수가 고차 함수 내에서만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.
```js
// 익명 함수 리터럴을 콜백 함수로 고차 함수에 전달한다.
// 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다.
repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 1 3
```
- 콜백 함수를 전달받는 함수가 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 함수 참조를 고차 함수에 전달하는 편이 효율적이다.
```js
// logOdds 함수는 단 한 번만 생성된다.
var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 고차 함수에 함수 참조를 전달한다.
repeat(5, logOdds); // 1 3
```
#### 순수 함수와 비순수 함수
- **함수형 프로그래밍에서 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 부수 효과가 없는 함수를 순수함수**라고 하고, **외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수를 비순수 함수**라고 한다.
- 순수 함수는 **동일한 인수가 전달되면 언제나 동일한 값을 반환한다.**
- 외부 상태에 의존하지 않아도 내부 상태가 호출될 때마다 변화나는 값이라면 순수 함수가 아니다.
- 순수 함수는 최소 하나 이상의 인수를 전달받고, **인수의 불변성을 유지한다.**
```js
var count = 0; // 현재 카운트를 나타내는 상태

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```
- 비순수 함수는 부수효과로 인해 상태 변화를 추적하기 어렵다.
```js
var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.

// 비순수 함수
function increase() {
  return ++count; // 외부 상태에 의존하며 외부 상태를 변경한다.
}

// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1

increase();
console.log(count); // 2
```
- **함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임**이다.
- 자바스크립트는 멀티 패러다임 언어로 객체지향 프로그래밍뿐만 아니라 함수형 프로그래밍을 적극적으로 활용하고 있다.