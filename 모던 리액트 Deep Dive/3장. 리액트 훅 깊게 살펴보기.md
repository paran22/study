## 3장 리액트 훅 깊게 살펴보기

### 3.1 리액트의 모든 훅 파헤치기

#### useState

- 클로저를 이용해 어떤 함수(useState) 내부에 선언된 함수(setState)가 함수의 실행이 종료된 이후에도(useState가 호출된 이후에도) 지역변수인 state를 계속 참조할 수 있다.
- 클로저를 통해 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 쓸 수 있고, 함수 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쓸 수 있다.
- 게으른 초기화 lazy initialization
  - state가 처음 만들어질 때만 사용하고, 이후 리렌더링이 발생된다면 실행이 무시된다.
  - 무거운 연산 등 실행 비용이 많이 드는 경우에는 게으른 초기화를 사용하는 것이 좋다.

#### useEffect

- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만든다.
  - 컴포넌트가 렌더링된 후에 어떠한 부수 효과를 일으키고 싶을 때 사용.
- 의존성에 있는 값이 이전과 하나라도 다른 게 있는 경우 부수 효과를 실행한다.
- 클린업 함수
  - 새로운 값과 함께 렌더링된 뒤에 실행되지만, 변경된 값이 아니라 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행됨.
  - useEffect는 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 클린업 함수를 실행한 뒤 콜백 실행 -> 특정 이벤트 핸들러가 무한히 추가되는 것을 방지한다.
  - 언마운트라기보다는, 리렌더링됐을 때 의존성 변화가 있다면 이전의 값을 기준으로 실행되는, 이전 상태를 청소해주는 개념이다.
- 의존성 배열
  - 빈 배열 : 최초 렌더링시에만 실행
  - 없음 : 렌더링할 때 마다 실행
    - 함수 컴포넌트 내에서 실행하는 것보다 useEffect로 실행하면 클라이언트 사이드에서 실행되는 것을 보장하고, 무거운 연산의 경우 렌더링을 지연시키는 것을 방지
    - Object.is를 기반으로 하는 얕은 비교를 수행한다.
- 주의할 점
  - 의존성 빈 배열을 사용할 때는 정말로 useEffect의 부수 효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 호출 위치가 적절한지 검토해야 한다.
  ```ts
  useEffect(
    function logActiveUser() {
      logging(user.id);
    },
    [user.id]
  );
  ```
  - 첫 번째 인수에 함수명을 부여하면 가독성을 높일 수 있다.
  - useEffect는 가능한 간결하고 가볍게 유지해라.
  - 불필요한 외부 함수를 만들지 마라: useEffect 내에서 사용할 부수 효과라면 내부에서 만들어서 사용해라.
  - useEffect 콜백 인수로 비동기 함수를 넣을 수 없다 : 비동기 함수의 응답 속도에 따라서 경쟁 상태가 발생할 수 있다.
    - 내부에서 비동기 함수를 선언해서 사용하는 것은 가능하나, 클린업 함수에서 이전 비동기 함수에 대한 처리를 추가하는 것이 좋다.

#### useMemo

#### useCallback

#### useRef

#### useContext

- useContext가 선언돼 있으면 Provider에 의존성이 생기고, Provider 하위에서만 실행할 수 있기 때문에 재활용하기 어려운 컴포넌트가 된다. -> useContext를 사용하는 컴포넌트를 최대한 작게 하거나, 재사용되지 않을 만한 컴포넌트에서 사용해야 한다.
- 리소스가 낭비되지 않도록 컨텍스트가 미치는 범위는 필요한 환경에서 최대한 좁게 만들어야 한다.
- useContext는 상태관리를 위한 것이 아니다.
  - 상태관리 라이브러리가 되기 위해서는 1. 어떤 상태를 기반으로 다른 상태를 만들어 낼 수 있어야 하고, 2. 필요에 따라 상태 변화를 최적화할 수 있어야 한다.
  - useContext는 컴포넌트 트리 전체가 리렌더링되며, 그 자체로는 렌더링 최적화에 도움이 되지 않는다.

#### useReducer

- state 값을 변경하는 시나리오를 제한적으로 두고 이에 대한 변경을 빠르게 확인할 수 있게 하는 것이 목적이다.
- state를 사용하는 로직과 이를 관리하는 비즈니스 로직을 분리할 수 있다.
- useState와 같이 클로저를 활용해 값을 가둬서 state를 관리한다.

#### useImperativeHandle

- forwardRef: ref는 예약어로 지정되어 있어 사용할 수 없고, ref를 전달하는 데 일관성을 제공하기 위해 사용
- 자식 컴포넌트에서 새롭게 설정한 객체의 키와 값에 대해서도 접근할 수 있다.

#### useLayoutEffect

- 모든 DOM의 변경 이후(렌더링 이후), 브라우저에 변경 사항이 반영되기 이전에 동기적으로 발생한다.
  - useEffect는 브라우저에 변경 사항이 반영된 이후에 실행된다.
- 실행 순서
  1. 리엑트가 DOM을 업데이트
  2. useLayoutEffect 실행
  3. 브라우저에 변경 사항 반영
  4. useEffect 실행
- DOM은 계산됐지만 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용 : 특정 DOM 요소를 기반으로 한 애니메이션, 스크롤 위치 제어 등

#### useDebugValue

- 다른 훅 내부에서만 실행할 수 있으며, 사용자 정의 훅 내부의 내용에 대한 정보를 남길 수 있다.
- 리액트 개발자 도구에서 확인할 수 있다.

#### 훅의 규칙

- 각 훅은 파이버 객체 내에서 순서에 의존해 state나 effect에 결과에 대한 값을 저장하고 있기 때문에 순서가 보장되도록 최상위에서만 훅을 호출해야 한다.
- 훅을 호출할 수 있는 것은 리엑트 함수 컴포넌트와 사용자 정의 훅 두 가지 경우 뿐이다.

### 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

#### 사용자 정의 훅

- 값을 반환하거나, 부수 효과를 실행한다.
- 리엑트 훅을 기반으로 하므로 리엑트에서만 사용할 수 있다.
- 리엑트에서 제공하는 훅으로만 공통 로직을 격리할 수 있다면 사용자 정의 훅을 사용하는 것이 좋다.
  - 사용자 정의 훅 그 자체로는 렌더링에 영향을 미치지 못하기 때문에, 컴포넌트 내부에 미치는 영향을 최소화해 개발자가 훅을 원하는 방향으로만 사용할 수 있다.

#### 고차 컴포넌트

- HOC, Higher Order Component
- 컴포넌트 자체의 로직을 재사용하기 위한 방법이다.
- 고차 함수의 일종으로, 리엑트가 아니더라도 자바스크립트 환경에서 사용할 수 있다.
- React.memo
- 컴포넌트를 인수로 받기 때문에 부수 효과를 최소화해야한다.
  - 컴포넌트 props를 임의로 수정, 추가, 삭제하지 않아야 하고, 추가적인 정보를 제공한다면 별도 props로 내려주는 것이 좋다.
- 여러 개의 고차 컴포넌트로 컴포넌트를 감쌀 경우 복잡성이 커진다.
- 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 고차 컴포넌트를 사용하는 것이 좋다.
  - 사용자 훅은 렌더링 결과물에 영향을 미치기 어렵다.
  - 렌더링 결과물에 영향을 미치기 때문에 사용자 정의 훅에 비해 예측하기 어렵다.
