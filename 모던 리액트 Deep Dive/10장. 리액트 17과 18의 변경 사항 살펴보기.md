## 10장. 리액트 17과 18의 변경 사항 살펴보기

### 10.1 리액트 17 버전 살펴보기

- 16버전과 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경사항을 최소화했다.

#### 10.1.1 리액트의 점진적인 업그레이드

- 전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전 업이 가능해진다.
- 리액트 팀은 이를 어디까지나 한꺼번에 업그레이드가 불가능한 상태에서만 차선책으로 사용하는 것을 권장함

#### 10.1.2 이벤트 위임 방식의 변경

- 리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부착하는 것이 아니라, 이벤트 타입(click, change) 당 하나의 핸들러를 루트에 부착한다(이벤트 위임).
- 이벤트는 캡처(이벤트 핸들러가 트리 최상단 요소부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것을 의미), 타깃(이벤트 핸들러가 타깃 노드에 도달하는 단계, 이 단계에서 이벤트 호출), 버블링(이벤트가 발생한 요소에서부터 최상위 요소까지 다시 올라감) 단계로 구성됨.
- 이벤트 위임이란 이벤트를 상위 컴포넌트에만 붙이는 것을 의미한다.
- 리엑트는 이벤트 핸들러를 각 요소가 아닌 document에 연결해서 이벤트를 좀 더 효율적으로 관리했다.
- 리액트 17부터는 document가 아닌 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 바뀌었다.
- 점진적인 업그레이드 지원, 바닐라 자바스크립트 코드 또는 jQuery 등이 혼재돼 있는 경우 혼란을 방지하기 위함.
- 각 이벤트는 해당 리액트 컴포넌트 트리 수준으로 격리되므로 이벤트 버블링으로 인한 혼란을 방지할 수 있다.
- 이러한 변경사항으로 인해 코드에 document.addEventListenner를 활용해 리액트의 모든 이벤트를 document에서 확인하는 코드가 있다면 여기까지 이벤트가 전파되지 않는 경우도 존재할 수 있어 확인이 필요하다.

#### 10.1.3 import React from 'react'가 더 이상 필요 없다: 새로운 JSX transform

- JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 활용해 JSX를 일반적인 자바스크립트로 변환하는 과정이 필요하다.
- 이 과정을 위해 import React from 'react'라는 구문이 필요했다.
- 리액트 17버전부터는 바벨과 협력해 이 구문이 없어도 JSX를 변환할 수 있게 되었다.
- 불필요한 import 구문을 삭제해 번들링 크기를 약간 줄일 수 있고, 컴포넌트 작성을 더욱 간결하게 해준다.

#### 10.1.4 그 밖의 주요 변경 사항

- 이벤트 풀링 제거

  - 리액트는 이벤트를 처리하기 위해 SyntheticEvent라는, 브라우저의 기본 이벤트를 한 번 더 감산 이벤트 객체를 사용해 서로 다른 이벤트 간에 이벤트 객체를 재사용했다.
  - 이벤트를 재사용하는 사이에 모든 이벤트 필드를 null로 변경하기 때문에, 비동기 코드 내부에서 합성 이벤트 e에 접근하기 위해서는 e.persist()d와 같은 추가적인 작업이 필요했다.
  - 별도 메모리 공간에 합성 이벤트 객체를 할당해야 하고, 모던 브라우저에서는 성능 향향에 크게 도움이 안되기 때문에 이벤트 풀링 개념은 삭제되었다.

- useEffect 클린업 함수의 비동기 실행

  - 리액트 16까지는 클린업 함수가 동기적으로 처리되어, 완료되기 전까지는 다른 작업을 방해해 불필요한 성능 저하 유발.
  - 리액트 17부터는 화면이 완전히 업데이트된 뒤에(커밋 단계가 완료된 후에) 비동기적으로 클린업 함수 실행

- 컴포넌트의 undefined 반환에 대한 일괄적인 처리
  - 리액트 16에서 forwardRef나 memo에서 undefined를 반환하는 경우 별다른 에러가 발생하지 않는다.
  - 리액트 17부터는 에러가 정상적으로 발생하고, 리엑트 18부터는 undefined를 반환해도 에러가 발생하지 않난다.

## 10.2 리액트 18 버전 살펴보기

#### 10.2.1 새로 추가된 훅 살펴보기

> useId
>
> - 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부의 고유한 값을 생성할 수 있다.

> useTransition
>
> - UI변경을 가로막지 않고 상태를 업데이트할 수 있다.
> - 과거 리액트의 모든 렌더링은 동기적으로 작동해 느린 렌더링 작업이 있을 경우 애플리케이션 전체적으로 영향을 끼쳤지만 useTransition과 같은 동시성을 지원하는 기능을 하용하면 느린 렌더링 과정에서 로딩 화면을 보여주거나 지금 진행중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링할 수 있다.
> - startTransition 내부에는 setState와 같이 상태를 업데이트 하는 함수와 관련된 작업만 넘길 수 있다.
> - startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다.
> - startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다.

> useDeferredValue
>
> - 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅이다.
> - 디바운스와 유사하지만, 디바운스와 달리 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 지연된 렌더링을 수행한다. 따라서 지연된 렌더링은 중단할 수도 있으며 사용자의 인터렉션을 차단하지도 않는다.
> - useTransition과 방식에서만 차이가 있고, 지연된 렌더링을 한다는 점에서는 동일하다.
> - 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트할 수 있는 코드에 접근할 수 있다면 useTransition이, 컴포넌트의 props처럼 상태 업데이트에 관여할 수는 없고 오로지 값만 받아야 하는 상황이라면 useDefferedValue가 타당하다.

> useSyncExternalStore
>
> - useSubscription의 구현이 대체되었다.
> - tearing: 하나의 state 값이 있음에도 서로 다른 값으로 렌더링 되는 현상을 말함.
> - 리엑트 18에서 useTransition, useDeferredValue의 등장으로 동시성 이슈가 발생해 tearing 현상이 나타날 수 있다.
> - 리엑트의 클로저 범위 밖에 있는, useState나 useReducer가 아닌 모든 외부 데이터 소스에서는 tearing 현상이 나타날 수 있다.
> - 이러한 문제를 해결하기 위해 등장한 것이 useSyncExternalStore이다.
> - 애플리케이션 코드에 직접적으로 사용할 일은 많지않다.

> useInsertionEffect
>
> - useEffect와 기본적인 훅 구조는 동일하나, DOM이 실제로 변경되기 전에 동기적으로 실행된다.
> - 브라우저가 레이아웃을 계산하기 전에 스타일을 삽입하는 코드를 넣어 좀 더 자연스럽게 스타일을 삽입할 수 있게 한다.
> - useLayoutEffect는 모든 DOM의 변경 작업이 끝난 후에 실행된다.
> - useInsertionEffect -> useLayoutEffect -> useEffect 순으로 순서된다.
> - 실제 애플리케이션을 작성할 때는 가급적 사용하지 않고, 라이브러리를 작성하는 경우에 참고할 수 있다.

#### 10.2.2 react-dom/client

- 클라이언트에서 리액트 트리를 만들 때 사용되는 API가 변경됐다.
- createRoot: render 대체
- hydrateRoot: 서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드

#### 10.2.3 react-dom/server

- 서버에서 컴포넌트를 생성하는 api가 변경됨.
- renderToPipeableStream: 리엑트 컴포넌트를 HTML로 렌더링하는 메서드, Stream을 지원한다.
- renderToReadableStream: 웹 스트림을 기반으로, 서버 환경이 아니라 클라우드나 디노와 같은 웹 스트림을 사용하는 모던 엣지 런타임에서 사용되는 메서드.

#### 10.2.4 자동배치(Automatic Batching)

- 리엑트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미한다.
- 17 이전에는 비동기 이벤트에서는 자동 배치가 이뤄지지 않고 있었다.
- 동기와 비동기 배치 작업이 일관성이 없었기 때문에, 이를 보완하기 위해 루트 컴포넌트를 createRoot를 사용해서 만들면서 모든 업데이트가 배치 작업으로 최적화할 수 있게 되었다.
- 자동 배치를 하고 싶지 않다면 flushSync를 사용하면 된다.

#### 10.2.5 더욱 엄격해진 엄격모드

- 리엑트의 엄격 모드는 리엑트에서 제공하는 컴포넌트 중 하나로, 리엑트 애플리케이션에서 발생할 수 있는 잠재적인 버그를 찾는데 도움을 주었다.
- 개발자 모드에서만 작동하고, 프로덕션 모드애서는 작동하지 않는다.
- 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
- 문자열 ref 사용금지
- findDOMNode에 대한 경고 출력
- 구 context API 사용 시 발생하는 경고
- 예상치 못한 부작용(side-effect) 검사
  - 함수형 프로그래밍의 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정한다. 엄격모드에서는 항상 순수한 결과물을 반환하는지 확인하기 위해 두 번 실행된다.
- 컴포넌트가 마운트 해제된 상태에서도 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공하기 위해 개발모드에서는 컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두 번째 마운트에서 이전 상태를 복원한다.

#### 10.2.6 Suspense 기능 강화

- Suspense가 정식으로 출시되면서 몇 가지 문제들이 개선되었다.
- effect는 컴포넌트가 실제로 화면에 노출될 때 실행된다.
- 컴포넌트가 Suspense에 의해 노출이 되면 useLayoutEffect의 effect가, 가려진다면 useLayoutEffect의 cleanUp이 실행된다.
- 서버에서도 Suspense가 실행된다. 서버에서는 일단 fallback 상태의 트리를 클라이언트에 제공하고, 불러올 준비가 된다면 렌더링 된다.
- Suspense 내에 스로틀링이 추가되었다. 중첩된 Suspense의 fallback이 있다면 자동으로 스로틀링된다.

#### 10.2.7 인터넷 익스플로어 지원 중단에 따른 추가 폴리필 필요

- 익스플로러 11을 지원해야 한다면 폴리필 설치 및 트랜스파일에 각별히 신경써야 한다.

#### 10.2.8 그 밖에 알아두면 좋은 변경사항

- 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않는다.
