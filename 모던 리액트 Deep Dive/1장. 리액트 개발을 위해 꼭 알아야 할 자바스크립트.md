## 1장. 리액트 개발을 위해 꼭 알아야할 자바스크립트

### 1.1 자바스크립트 동등비교

- 리액트는 props의 동등비교는 객체의 얕은 비교
- undefined는 선언됐지만 할당되지 않은 값, null은 명시적으로 비어 있음을 나타내는 값
- 객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy
- 원시타입은 불변 형태의 값으로 저장, 변수 할당 시점에 메모리 영역을 차지하고 저장됨
- 객체는 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달
- Object.is

  - 타입과 값을 모두 비교
  - ==과 ===보다 개발자가 기대하는 방식으로 비교

    ```ts
    -0 === +0; //false
    Object.is(-0, +0); //true

    Number.NaN === NaN; //false
    Object.is(Number.NaN, NaN); //true

    NaN === 0 / 0; //false
    Object.is(NaN, 0 / 0); //true
    ```

  - 객체를 비교할 때는 동일하게 참조를 비교

- 리엑트의 동등 비교

  - Object.is로 비교 수행
  - 객체의 경우 얕은 비교 : 첫 번째 깊이에 존재하는 값만 비교

    ```ts
    // Object.is는 참조가 다른 객체에 대해 비교가 불가능하다.
    Object.is({ hello: "world" }, { hello: "world" }); //false

    // 리엑트 팀이 구현한 shallowEqual은 객체의 1depth까지는 비교가 가능하다.
    shallowEqual({ hello: "world" }, { hello: "world" }); //true

    // 그러나 2 depth까지 가면 이를 비교할 방법이 없어 false를 반환한다
    shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); //false
    ```

- props로 객체를 전달할 때 React.memo의 메모라이제이션이 동작하지 않는 등리엑트 렌더링이 예상치 못하게 작동할 수 있다.

### 1.2 함수

- 함수는 일급 객체이다 : 다른 함수의 매개변수가 될 수 있고, 반환값이 될 수 있고, 할당도 가능하다.
- 함수 표현식과 선언식의 차이
  - 함수 표현식은 함수 호이스팅이 아니라 변수 호이스팅이 적용된다.
- Function 생성자 : 권장되지 않음
- 화살표 함수
  - constructor를 사용할 수 없디.
  - arguments가 존재하지 않는다.
  - 일반적으로 js에서 this 바인딩은 함수를 정의할 때가 아니라 함수가 호출되는지에 따라 결정되는데, 화살표 함수는 함수 자체의 바인딩을 갖지 않고 상위 스코프의 this를 따른다.
- 즉시 실행 함수 : 독립적인 함수 스코프를 운용할 수 있다. 재사용되지 않는 함수이고 단 한번만 실행되고 끝난다면 즉시 실행 함수의 사용을 검토할 수 있다.
- 고차 컴포넌트 : 고차 함수의 특징을 활용해, 함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환
- 함수를 만들 때 주의할 점
  - 함수의 부수 효과를 최대한 억제하기
  - 가능한 함수를 작게 만들기
  - 네이밍 : useEffect나 useCallback 등 훅이 넘겨주는 콜백 함수에 네이밍을 붙여주면 가독성에 도움이 된다.

### 1.3 클래스

- 자바스크립트에서 클래스로 하는 모든 것들은 함수로도 동일하게 표현 가능
- 접근제어자
  - #를 사용해서 private을 선언하는 방법이 ES2019에 추가됨
  - 타입스크립트를 활용하면 private, protected, public을 사용할 수 있다.
- 인스턴스 메서드는 실제로 protytype에 선언됨 : 프로토타입 메서드라고도 함
- 정적 메서드 내부의 this는 클래스 자신을 가리키기 때문에 this를 사용할 수 없다.

### 1.4 클로저

- 클로저는 함수와 함수가 선언된 어휘적 환경의 조합 : **선언된 어휘적 환경**이란 변수가 코드 내부에서 어디에 선언됐는지를 말한다.

  ```ts
  function outer() {
    let outerVariable = "outer";
    function inner() {
      console.log(outerVariable);
    }
    return inner;
  }

  const innerFunction = outer();
  // 선언된 환경을 기억하기 때문에 outerVariable을 출력할 수 있다.
  innerFunction(); // 'outer'
  ```

- 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 원하는 방향으로 노출시킬 수 있다.
- useState는 클로저이다 : useState 호출이 끝나고 나서도 setState는 계속 최신값을 알고 있다.
- 생성될때마다 선언적 환경을 기억하므로 추가 비용이 발생한다.

### 1.5 이벤트 루프와 비동기 통신의 이해

- 하나의 프로세스에서는 여러 개의 스레드를 만들 수 있고, 스레드끼리는 메모리를 공유할 수 있어 여러 가지 작업을 동시에 수행할 수 있다.
- 이벤트 루프
  - ECMAScript 자바스크립트 표준에 나와 있는 내용은 아니다.
  - 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치이다.
  - 호출 스택(call stack) : 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택
  - 이벤트 루프만의 단일 스레드 내부에서 호출 스택 내부에 수행해야할 작업이 있는지 확인하고 수행해야할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다.
  - 코드를 실행하는 것과 호출 스택이 비어있는지 확인하는 것 모두 단일 스레드에서 일어난다.
  - 태스크 큐
    - 실행해야할 태스크의 집합
    - 이벤트 루프는 한 개 이상의 태스크 큐를 가지고 있다.
    - 실행 가능한 가장 오래된 태스크를 가져오기 위해 set이다.
    - 비동기 함수는 자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 브라우저나 Node.js에서 별도의 스레드에서 실행되고 콜백이 태스크 큐로 들어간다.
    - 이벤트 루프는 호출 스택이 비고 콜백이 실행 가능한 때가 오면 이것을 꺼내서 실행한다.
  - 마이크로 태스크 큐
    - 이벤트 루프는 하나의 마이크로 태스크 큐를 가지고 있다.
    - Promise는 마이크로 태스크 큐에서 처리한다.
    - 태스크 큐보다 우선권을 갖는다 : 태스크 큐가 빌 때까지 태스크 큐가 실행되지 않는다.
    - 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다.
    - 렌더링은 마이크로 태스크 큐와 태스크 큐 사이에 일어난다.

### 1.6 리엑트에서 자주 사용하는 자바스크립트 문법

- 구조 분해 할당
  - 배열 구조 분해 할당
    - 자유롭게 이름을 선언할 수 있다 -> useState
    - 기본값 선언 가능 : 기본값은 반드시 undefined일 때만 사용
  - 객체 구조 분해 할당
    - 변수에 있는 값으로 꺼내오는 계산된 속성 이름 방식도 가능
    ```ts
    const key = "a";
    const { [key]: value } = { a: 1, b: 2 };
    ```
    - ECMA 2018에 도입
    - 트랜스파일을 거치면 번들링 크기가 상대적으로 크기 때문에, 웹 애플리케이션 개발 환경이 ES5를 고려해야 하고, 객체 구조 분해 할당을 자주 쓰지 않는다면 꼭 써야하는지 검토할 필요가 있음
- Array.prototype.forEach는 배열 순회를 멈출 수 없다(break, return 불가)

### 1.7 선택이 아닌 필수, 타입스크립트

- 타입 체크를 정적으로 런타임이 아닌 빌드(트랜스파일) 타임에 수행
- 리엑트 활용법
  - any 대신 unknown
  - 타입 가드 활용
  - 제네릭
  - 인덱스 시그니처 : 키에 원하는 타입을 부여할 수 있다
    ```ts
    type Hello = {
      [key: string]: string;
    };
    ```
  - Object.keys는 string[]을 반환한다.
    - 자바스크립트는 어떤 객체가 필요한 변수와 메서드만 지니고 있으면 해당 타입에 속하도록 인정하는 덕 타이핑이기 때문
    - 모든 키가 들어올 수 있는 가능성이 열려있는 객체의 키에 포괄적으로 대응하기 위해 string[]으로 타입 제공
  - 타입스크립트 전환 가이드
    - JSDoc과 @ts-check를 활용해 점진적으로 전환
    - 타입 기반 라이브러리 사용을 위해 @types 모듈 설치
    - 파일 단위로 조금씩 전환
