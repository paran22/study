## 2장 리액트 핵심 요소 깊게 살펴보기

### 2.1 JSX란?

- JSX는 XML과 유사한 내장형 구문이며, 리엑트에 종속적이지 않은 독자적인 문법
- ECMAScript 자바스크립트 표준이 아니다.
- 자바스크립트 내부에서 표혀하기 까다로웠던 XML 스타일의 트리 구문을 작성하는 데 도움을 주는 새로운 문법이다.
- \를 이스케이프 문자열로 처리하고 있지 않다.
- @babel/plugin-transform-react-jsx는 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환한다.

### 2.2 가상DOM과 리액트 파이버

- DOM은 웹페이지에 대한 인터페이스로 브라우저가 웹페이지 콘텐츠의 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.
- 가상 DOM이 만들어진 이유
  - SPA는 페이지가 변경되면 처음부터 HTML을 새로 받아서 다시 렌더링을 시작하는 일반적인 웹페이지와 다르게 하나의 페이지에서 계속해서 요소의 위치를 재계산하는 추가 렌더링 작업이 많아진다.
  - 개발자도 DOM의 모든 변경 사항을 추적하는 것이 어렵고, 결과적으로 만들어지는 DOM만 알고 있어도 된다.
- 가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고, 리엑트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM을 반영한다.
  - 브라우저가 아닌 메모리에서 계산하여 렌더링 과정을 최소화하고 브라우저와 개발자의 부담을 덜 수 있다.
- 가상 DOM은 대부분의 상황에서 웬만한 애플리케이션을 만들 수 있을 정도로 충분히 빠름(항상 빠른 것이 아님)

#### 리엑트 파이버(React Fiber)

- 가상 DOM과 렌더링 과정 최적화를 가능하게 해줌
- 리엑트에서 관리하는 자바스크립트 객체로, 파이버 재조정자(fiber reconciler)과 관리한다.
- 리엑트 컴포넌트에 대한 정보를 1:1로 가지고 있다.
- 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하고, 차이가 발생하면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링 요청
- 재조정(reconciliation) : 리엑트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)
- 모든 과정은 비동기
  - 기존 렌더링 스택은 동기 : 작업이 많을 경우 렌더링이 지연될 수 있다.
  - 렌더 단계 : 비동기 작업 수행, 파이버는 우선순위를 지정하거나 중지시키거나 버리는 작업을 한다.
  - 커밋 단계 : DOM에 실제 변경 사항을 반영하기 위한 작업, 동기식으로 일어나고 중단될 수 없다.
- 렌더링이 발생할 때 마다 새롭게 생성되는 리엑트 요소와 달리, 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적 재사용된다.
- state 변경, 생명주기 메서드, DOM의 변경이 필요한 시점 등에 파이버 실행
  - 리엑트가 파이버를 처리할 때마다 작업을 직접 바로 처리하기도 하고 스케줄링 하기도 한다.
- 리엑트는 가상 DOM이 아닌 Value UI, 즉 값을 가지고 있는 UI를 관리하는 라이브러리이다.

#### 파이버 트리

- 리엑트 내부에는 현재 모습을 담은 파이버 트리와, 작업 중인 상태를 나타내는 workInProgress 트리가 있다.
- 더블 버퍼링: 리엑트 파이버의 작업이 끝나면 리엑트는 커밋단계에서 포인터만 변경해 workInProgress 트리를 현재 트리로 바꾼다.
- 가상 DOM과 리엑트의 핵심은 브라우저의 DOM을 빠르게 반영하는 것이 아니라 값으로 UI를 표현하고, 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이다.

### 2.3 클래스 컴포넌트와 함수 컴포넌트

#### 클래스 컴포넌트

- 생명주기 메서드
  - 실행 시점: 마운트, 업데이트, 언마운트
  - render
    - 컴포넌트가 UI를 렌더링하기 위해 사용
    - 마운트와 업데이트 과정에서 일어남
    - 항상 순수해야 하며 부수 효과가 없어야 함
    - this.state를 호출하면 안된다.
  - componentDidMount
    - 컴포넌트가 마운트된 다음에 바로 호출
    - this.setState()로 state 변경 가능 : 브라우저가 실제로 UI를 업데이트 하기 전에 실행되어 사용자가 변경을 눈치챌 수 없음
    - 성능에 유의
  - componentDidUpdate
    - 컴포넌트 업데이트 이후 바로 실행
    - this.setState를 호출할 수 있으나 계속 호출될 수 있어 주의
  - componentWillUnmount
    - 언마운트 직전에 호술
    - this.setState 호출 불가
  - shouldComponentUpdate
    - 리렌더링을 일으키지 않는다
    - Component는 state가 업데이트되는 대로 렌더링이 일어나지만, PureComponent는 state 값에 대한 얕은 비교를 수행해 결과가 다를 때만 렌더링 수행(얕은 비교이기 때문에 state가 복잡한 객체일 경의 주의 필요)
  - static getDerivedStateFromProps
    - deprecated 된 componentWillReceiveProps를 대체
    - 다음에 올 props를 바탕으로 현재의 state를 변경하고 싶을 때 사용
    - 모든 render 시에 수행되어 주의 필요
  - getSnapshotBeforeUpdate
    - componentWillUpdate 대체
    - DOM 업데이트 직전에 호출
    - DOM에 렌더링되기 전에 윈도우 크기 조절, 스크롤 위치 조정할 때 유용
  - ErrorBoundary
    - getDerivedStateFromError
      - 자식 컴포넌트에 에러가 발생됬을 때 호출
      - 반드시 state 값을 반환해야 함
      - 렌더링 과정에서 호출되는 메서드이기 때문에 부수효과를 발생시켜서는 안된다.
    - componentDidCatch
      - 자식 컴포넌트에 에러가 발생했을 때, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행
      - 커밋 단계에 수행되기 때문에 getDerivedStateFromError에서 하지 못한 부수 효과 수행 가능 ex. 에러 로깅
      - 개발 모드와 프로덕션 모드에서 다르게 작동함 : 개발과 달리 프로덕션 모드에서는 componentDidCatch에서 잡히지 않은 에러만 window까지 전파됨
    - ErrorBoundary를 여러 개 선언해서 컴포넌트별로 에러 처리를 다르게 표시할 수 있다.
      - 에러가 발생한 트리 영역만 별도로 처리해 애플리케이션 전체에 에러 전파되는 것을 방지할 수 있다.
- 단점
  - 데이터 흐름을 추적하기 어렵다.
    - 서로 다른 여러 메서드에서 state의 업데이트가 일어날 수 있고, 메서드 순서가 강제돼어 있지 않아 읽기 어렵다.
  - 애플리케이션 내부 로직 재사용이 어렵다.
    - 로직을 재사용하려면 HOC나 props로 전달해야한다 -> Wrapper hell에 빠지기 쉽다.
  - 기능이 많아질수록 컴포넌트 크기가 커진다.
  - 클래스는 함수에 비해 상대적으로 어렵다.
  - 코드 크기를 최적화하기 어렵다.
  - 핫 리로딩을 하는데 상대적으로 불리하다.
    - state를 클로저에 저장해 함수를 다시 실행해도 state를 잃지 않는 함수 컴포넌트와 달리, instance를 새로 만들기 때문에 state가 초기화된다.

#### 함수 컴포넌트

- 클래스 컴포넌트와의 차이
  - 생명주기 메서드 부재
    - useEffect는 생명주기를 위한 훅이 아니라, 컴포넌트의 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘
  - 함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링 되고, 클래스 컴포넌트는 변경될 수 있는 this를 기준으로 렌더링이 일어난다.
    - setTimeout으로 3초 뒤 alert가 뜰 때, 중간에 state가 값이 변경하면 함수 컴포넌트는 변경되기 이전 값이, 클래스 컴포넌트는 변경된 값이 반영된다.
  - 자식 컴포넌트에서 발생한 에러에 대한 처리는 현재 클래스 컴포넌트로만 가능하다.

### 2.4 렌더링은 어떻게 일어나는가?

- 브라우저에서의 렌더링이란 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정
- 리엑트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정
- 최초 렌더링 이후 리렌더링이 발생하는 경우
  - 클래스 컴포넌트의 setState가 실행되는 경우
  - 클래스 컴포넌트의 forceUpdate가 실행되는 경우
  - 함수 컴포넌트의 useState의 setter가 실행되는 경우
  - 함수 컴포넌트의 useReducer의 dispatch가 실행되는 경우
  - 컴포넌트의 key props가 변경되는 경우
    - key는 current트리와 workInProgress 트리 사이에서 어떤 컴포넌트가 변경이 있었는지를 구별하기 위해 사용됨
  - props가 변경되는 경우
  - 부모 컴포넌트가 렌더링될 경우
- 리엑트 렌더링 프로세스
  - 렌더링 프로세스가 시작되면 컴포넌트의 루트에서부터 아래로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
  - 각 컴포넌트의 렌더링 결과물을 수집한 다음, 리엑트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 수집
  - 이렇게 계산하는 과정을 재조정(reconciliation)이라고 한다.
  - 재조정 과정이 모두 끝나며 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.
- 렌더와 커밋
  - 렌더 단계(Render Phase)
    - 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
    - type, props, key 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크
  - 커밋 단계(Commit Phase)
    - 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
    - 리엑트가 커밋 단계에서 DOM을 업데이트하면 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리엑트 내부의 참조를 업데이트 함
    - 이후 클래스 컴포넌트의 componentDidMount, componentDidUpdate / 함수 컴포넌트 useLayoutEffect 호출
    - 리엑트의 렌더링이 일어난다고 무조건 DOM이 업데이트되는 것이 아님
      - 렌더링 이후 커밋 단계가 필요하지 않으면 생략될 수 있음
    - 리엑트 렌더링은 항상 동기식으로 작동했으나, 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링인 동시성 렌더링이 리엑트 18에 도입됨
      - 렌더 단계가 비동기로 작동

### 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

#### 주장1. 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

- 대부분의 가벼운 작업 자체는 메모이제이션해서 메모리에 저장하고 꺼내오는 것보다 매번 이 작업을 수행해 결과를 반환하는 것이 더 빠를 수도 있다.
- 메모이제이션도 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 이전 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다.
- 일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화 하는게 옳다.

#### 주장2. 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

- 리엑트의 기본적인 알고리즘 때문에 이전 결과물은 저장해두고 있기 때문에, 잘못된 memo로 지불해야 하는 비용은 props에 대한 얕은 비교가 발생하면서 지불하는 비용뿐이다.
- memo를 하지 않았을 때 잠재적으로 발생할 수 있는 위험 비용이 더 크다.
  - 렌더링을 함으로써 발생하는 비용
  - 컴포넌트 내부의 복잡한 로직의 재실행
  - 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
  - 리엑트가 구 트리와 신규 트리를 비교
- 모든 객체는 재생성되어 참조가 달라지는데, 이 값이 useEffect와 같은 의존성 배열에 쓰이면 변경된 참조로 다른 쪽에도 영향을 미칠 것이다.
- 메모이제이션은 컴포넌트 자신의 리렌더링뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고저오딘 값을 사용할 수 있다는 믿음을 줄 수 있다.
